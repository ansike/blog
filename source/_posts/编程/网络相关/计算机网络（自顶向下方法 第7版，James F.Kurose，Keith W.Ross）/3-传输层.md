---
title: 传输层
categories: 编程
tags:
  - 网络
date: 2023-05-04 17:35:01
---

来自[中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程](https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click&vd_source=22653c02dfbe0c9c7bb4a200eb87fe4e)


<a href="#overview">3.1 传输层概述</a>
<a href="#reuse">3.2 多路复用解复用</a>
<a href="#udp">3.3 无连接传输 UDP</a>
<a href="#rdt">3.4 可靠数据传输的原理</a>
<a href="#tcp">3.5 面向连接的传输 TCP</a>
<a href="#jam">3.6 拥塞控制原理</a>
<a href="#tcpjam">3.7 TCP拥塞控制</a>

<h1 id="overview">3.0 传输层概述</h1>
- 理解传输层的工作原理
  - 多路复用/解复用
  - 可靠数据传输
  - 流量控制
  - 拥塞控制
- 学习internet的传输层协议
  - TCP
    - TCP的拥塞控制
  - UDP
  
<h1 id="reuse">3.1 多路复用解复用</h1>

TCP的复用和解复用

TCP的socket其实是以下四元组的一个数字标识和唯一一个PID对应
在连接建立之后在服务器和客户端都会在内存中建立一个唯一的socket连接
发送方发送数据时【源IP，源端口】=>【目标IP，目标端口】会复用该socket进行发送
接收方收到数据时解析数据包中的IP和端口信息，找到唯一的socket，把报文交给socket对应的process处理

**TCP socket map**
| socket | 源IP      | 源端口 | 目标IP    | 目标端口 | PID    |
| ------ | --------- | ------ | --------- | -------- | ------ |
| 12     | 127.0.0.1 | 80     | 127.0.0.2 | 8090     | 123123 |

> 浏览器在加载站点资源时通过创建多个socket连接来实现并发请求，此时每个socket请求的客户端端口都是不一样的。

TCP的复用和解复用
UDP的socket是二元组的一个数字标识和唯一的一个PID对应
UDP本身是面向无连接的，所以socket仅仅记录了自身IP，port和PID的对应关系
发送方通过同一个port发送数据时会使用同一个socket进行发送
接收方收到数据时解析数据包中的IP和port信息，找到唯一的socket，把报文交给socket对应的process处理
**UDP socket map**
| socket | 源IP      | 源端口 | PID    |
| ------ | --------- | ------ | ------ |
| 12     | 127.0.0.1 | 80     | 123123 |

<h1 id="reuse">3.2 无连接传输 UDP</h1>

UDP User Datagram Protocol [RFC 768]

UDP 只在IP层上增加了复用和解复用的能力

UDP使用的场景：流媒体，DNS，SNMP

在UDP上实现可靠传输：
- 在应用层增加可靠传输
- 应用特定的差错恢复

QQ的通讯就是基于UDP的OICQ应用层协议

**为什么没有第三种应用？**
TCP和UDP已经能支撑85%以上的应用

**为什么叫数据报**
每个数据都是独立发送的，IP也叫数据报

- udp头部比较小，payload比较大
- 没有拥塞控制，流量控制，发送比较快

UDP 校验和
- 目标：检测被传输报文段中的差错（如比特反转）
- 发送方
  - 将报文的内容视为16比特的整数
  - 校验和：报文段的加法和（1的补运算）
  - 发送方将校验和放在UDP的校验和字段
- 接收方
  - 计算机接收到的报文段的校验和
  - 检查计算出的校验和与校验和字段是否相等
    - 不想等：检测到有差错
    - 相等：没有检测到差错，但也有可能有差错
      - 残存错误


<h1 id="rdt">3.3 可靠数据传输的原理</h1>

**可靠数据传输（rdt [reliable data transfer]）的原理**
- rdt在应用层、传输层和数据链路层都很重要
- 是网络Top 10问题之一
{% asset_img 20230528-225749.jpeg rdt %}
- 信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性

渐进式的开发可靠数据传输协议
- rdt1.0 在可靠的信道上可靠数据传输
- rdt2.0 具有比特差错的信道
  - 下层信道可能出错：将分组中的比特反转
    - 用校验和来检测比特差错
  - 怎么从差错中恢复？
    - 确认（ACK）：接收方显示的告诉发送方分组已经被接受
    - 否定确认（NAK）：接收方显示的告诉发送方分组错误
      - 发送方收到NAK之后，发送方重传分组
  - rdt2.0中的新机制：采用差错控制编码进行差错检测 
    - 发送方差错控制编码、缓存 
    - 接收方使用编码检错 
    - 接收方的反馈：控制报文（ACK，NAK）：接收方->发送方 
    - 发送方收到反馈相应的动作
  - 致命的缺陷：ACK/NAK出错
    - 发送方不知道接收方发送了什么
    - 发送方如何做
      - 重传：可能重复
      - 不重传：可能死锁（或出错）
    - 引入新的机制：序号
- rdt2.1 在2.0上增加序号的能力
    - 发送方在每个分组中加入序号
    - 如果ACK/NAK出错，发送方重传当前分组
    - 接收方丢弃（不发给上层）重复分组
- rdt2.2 无NAK的协议
  - 功能同rdt2.1，但只使用ACK(ack 要编号）
  - 接收方对最后正确接收的分组发ACK，以替代NAK
    - 接收方必须显式地包含被正确接收分组的序号
  - 当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组
  - 为后面的一次发送多个数据单位做一个准备
    - 一次能够发送多个
    - 每一个的应答都有：ACK，NACK；麻烦
    - 使用对前一个数据单位的ACK，代替本数据单位的nak
    - 确认信息减少一半，协议处理简单
- rdt3.0：具有比特差错和分组丢失的信道
  - 下层信道可能会丢失分组（数据或ACK）
    - 会死锁
    - 机制还不够处理这种状况： 
      - 检验和 
      - 序列号
      - ACK
      - 重传
  - 方法：发送方等待ACK一段合理的时间
    - 发送端超时重传：如果到时没有收到ACK->重传
      - 问题：如果分组（或ACK ）只是被延迟了： 
        - 重传将会导致数据重复，但利用序列号已经可以处理这个问题 
        - 接收方必须指明被正确接收的序列号
      - 需要一个倒计数定时器
{% asset_img 20230528-225749.jpeg rdt %}
  
**停止等待协议**
发送方发送一个分组，然后等待接收方的应答。收到接收方的应答之后再发后续的分组

{% asset_img 20230530-090937.jpeg rdt3.0 %}
{% asset_img 20230530-090952.jpeg 流水线 %}
{% asset_img 20230530-091007.jpeg 流水线协议 %}

**滑动窗口(slide window)协议**
- 发送缓冲区 
  - 形式：内存中的一个区域，落入缓冲区的分组可以发送 
  - 功能：用于存放已发送，但是没有得到确认的分组 
  - 必要性：需要重发时可用
- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组 
  - 停止等待协议=1 
  - 流水线协议>1，合理的值，不能很大，链路利用率不能够超100%
- 发送缓冲区中的分组 
  - 未发送的：落入发送缓冲区的分组，可以连续发送出去；
  - 已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除

**GBN协议和SR协议的异同**
- 相同之处
  - 发送窗口>1
  - 一次能够可发送多个未经确认的分组
- 不同之处
  - GBN :接收窗口尺寸=1
    - 接收端：只能顺序接收 
    - 发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4 ; 假如1未成功，234都发送出去了，要返回1再发送；GB1
  - SR: 接收窗口尺寸>1
    - 接收端：可以乱序接收 
    - 发送端：发送0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发，选择性发送1

**流水线协议：总结**
- Go-back-N:
  - 发送端最多在流水线中有N个未确认的分组
  - 接收端只是发送累计型确认cumulative ack
    - 接收端如果发现gap，不确认新到来的分组
  - 发送端拥有对最老的未确认分组的定时器
    - 只需设置一个定时器
    - 当定时器到时时，重传所有未确认分组
- Selective Repeat: 
  - 发送端最多在流水线中有N个未确认的分组
  - 接收方对每个到来的分组单独确认individual ack（非累计确认）
  - 发送方为每个未确认的分组保持一个定时器
    - 当超时定时器到时，只是重发到时的未确认分组

TCP 主要使用的是GBN协议，发送方可以连续发送多个报文段无需等待每个报文段的确认。SR协议可以缓存乱序到达的报文段，并按需发送确认信息。

<h1 id="tcp">3.5 面向连接的传输 TCP</h1>

**段结构**

TCP：概述 RFCs: 793, 1122, 1323, 2018, 2581
- 点对点：
  - 一个发送方，一个接收方
- 可靠的、按顺序的字节流：
  - 没有报文边界
- 管道化（流水线）：
  - TCP拥塞控制和流量控制设置窗口大小
- 发送和接收缓存
- 全双工数据：
  - 在同一连接中数据流双向流动
  - MSS：最大报文段大小 MTU internet的大小是 1500B
一个报文+20B的TCP头部+20B的IP头部，如果正好小于1500B则正好在一个报文段中，传输内容大小为1460B，超过1500B之后需要分段发送。
- 面向连接：
  - 在数据交换之前，通过握手（交换控制报文） 初始化发送方、接收方的状态变量
- 有流量控制：
  - 发送方不会淹没接收方

{% asset_img 20230531-090326.jpeg tcp 报文 %}

此图中的req和ack解释
- 改图描述了全双工的信息发送过程
- Seq 标识当前数据的序号，ACK则是对之前收到数据的确认（值为上次Seq+报文的长度），希望下次发送方发送数据从ACK的值开始
- ACK是累计确认，对下次接受数据的期待
{% asset_img 20230601-084345.jpeg tcp 序号和确认号 %}

TCP往返延时（RTT）和超时
<!-- TODO 计算方式没有看懂 -->
TimeoutInterval = EstimatedRTT + 4 * DevRTT（safety margin）
先计算一个往返时间的估计值+偏差范围的4倍，能覆盖绝大多数的超时 情况

**可靠数据传输**

- 产生TCP ACK的建议
1. 接收方收到一个报文之后 会启动一个辅助定时器，最多等待500ms，如果500ms内期望的下一个报文到达的话，接收方给发送方发送一个累计确认的ACK。如果超过500ms还没到给发送方一个第二个报文的期望
2. 前边一个报文没给确认，来第二个之后立即给发送方确认
3. 接收方接收到乱序报文之后立即给发送方一个期望确认
4. 接收方收到钱后两个报文，中间的报文有gap时，理解给发送方预期的ACK。
   
- 快速重传
在超时定时器还没有到时间前，收到三个冗余的ACK，此时发送方会再次重传数据包。搞动作就是快速重传，因为此时还没有超时

- 三个冗余的ACK是怎么来的？
这个时候虽然没有超时，但是三个冗余ACK让发送方猜测序号较小的数据报出了问题，会立即重新发送，节约时间

- 初始的Seq为什么不从0开始？
初始的数据不是从0开始，而是双方会协商一个双向发送的Seq。因为有可能发生之前同端口的传输的数据突然到达导致数据错乱。

TCP在数据传输过程中只启动一个定时器，当收到一个ACK时，移动base指针到ACK确认的位置。如果此时base指针小于next指针说明还有已发送未确认的包，则重新启动定时器，如果base和next相等则无已发送的包，关闭定时器。
{% asset_img 20230601-091627.jpeg TCP发送方事件 %}

**流量控制**
接受方不让发送方发送的太多太快以至于让接受方的缓冲区溢出。
接收方可以在回复消息的时候将ACK和空闲缓存区的大小告诉发送方，发送方收到消息之后可以控制自己的速率

**连接管理**
TCP 三次握手：协商发送段的开始序号建立socket
1. client向server说开始从x开始发送数据
2. server向client回复确认
3. server向client说开始从y开始发送数据
4. client向server回复确认
其上2和3都是server向client发送的消息，合成一个之后就可以最简化到三次握手就可建立连接。

TCP 四次挥手
1. client向server 发送断开链接的消息
2. server向client 发送确认
   过一段时间之后
3. server向client 发送断开链接的消息
4. client向server 发送确认

以上的2和3无法直接合并，所以需要四次。
断开连接1，2时client表达了自己的意图也收到server的确认，但是server仅仅是收到了期望且发送了自己的确认，但是并不完全清楚client是否真的收到了自己的确认。为了解决该问题，server在发送完确认之后会启动一个定时器，在timeout之后服务端没收到客户端的任何数据，服务端才会断开连接。3，4方向也一样。

<h1 id="jam">3.6 拥塞控制原理</h1>

流量控制是端到端的问题
拥塞控制是网络的问题

**拥塞的代价**
1. 延迟比较大
2. 为了让网络达到有效的输出需要很高的输入
3. 拥塞时可能需要重传很多数据

超时重传可以保证数据不丢失，但也会加剧网络拥塞的情况。
负反馈往往会使系统趋于平衡，而正反馈往往会让系统奔溃

**拥塞控制的方法**
1. 端到端拥塞控制（TCP采用的方式）
- 没有来自网络的显式反馈
- 端系统根据延迟和丢失时间判断是否有拥塞
2. 网络辅助的拥塞控制
- 路由器提供给端系统以反馈信息
  - 单个bit置位，显示有拥塞（SNA，DECbit，TCP/IP ECN，ATM）
  - 显式提供发送端可以采用的速率

ATM ABR 拥塞控制 （网络辅助的拥塞控制）
ABR: available bit rate
- 如果发送端的路径“轻载”，发送方使用可用带宽
- 如果发送方的路径拥塞了 放松方限制其发送的速度到一个最小保障的速率上

发送方怎么知道拥塞以及最小保障是多大？
数据传输过程中会在中间节点上增加RM（资源管理信元）标识了是否拥塞以及最低的速率是多少


<h1 id="tcpjam">3.7 TCP拥塞控制</h1>

TCP使用的拥塞控制机制是端到端的控制机制【端系统根据自身得到的信息判断是否发生拥塞从而采取动作】

**拥塞控制需要考虑的几个问题**
1. 如何检测拥塞（拥塞感知）
  - 轻微拥塞
  - 拥塞
2. 控制策略实现
  - 拥塞时如何动作，降低速率
    - 轻微拥塞 如何反应
    - 拥塞， 如何反应
  - 拥塞缓解时如何动作，增加速率

**拥塞感知**
1. timeout 【拥塞】
  超时的原因
  - 网络拥塞，某个路由器缓存区没空间导致丢包（概率较大）
  - 数据出错，没通过校验被丢弃（概率小）
2. 收到三次重复的ACK 【轻微拥塞】

**速率控制的方法**
1. 前提
- 维持一个拥塞窗口的值：CongWin
- 发送端限制已发送未确认的数量 LastByteSent-LastByteAcked <= CongWin
2. 具体策略
- 慢启动
  刚启动时发送1MSS的包，之后快速增大速率。
- AIMD：线性增，乘性减少
  - SS阶段：加倍增加（每个RTT）
  - CA阶段：线性增加（每个RTT）
- 超时之后的保守策略
  识别到超时或者三个重复的ACK时CongWin降低
  - 超时后 CongWin降低为 1MSS，进入SS阶段
  - 三个重复ACK CongWin降低为 1/2 CongWin，进入CA阶段


MSS（Max Segment Size）最大报文段长度 1460

拥塞控制发送速率也需要满足流量控制
SendWin = min(CongWin, RecvWin)

**TCP慢启动初始速率**
一个IP的大小是1500，抛掉头部之后是1460，一个TCP的包大小是1460，总共是 1460*8 bit
1460*8/200 =  58.4kbps


**TCP的启动过程**
1. TCP刚启动时设置CongWin=1MSS，此时发送速率成倍增加
2. 当发生三次冗余ACK时，设置Threshold=CongWin/2，CongWin=Threshold+3，此时进入CA阶段，发送速率线性增长
3. 当超时时，Threshold=CongWin/2，CongWin=1MSS，此时进入SS阶段，发送速率指数增长。当速率到达Threshold时，进入CA阶段，发送速率线性增长

**TCP的吞吐量**
TCP数据发送的过程就是CongWin动态调整的过程，不断在w/2到w之间动态调整。
平均窗口大小 = (w/2+w)/2 = 3/4w
avg TCP thruput = 3/4 * W/RTT bytes/sec

**TCP公平性**
K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R/K
{% asset_img 20230610-223552.jpeg tcp 公平 %}


