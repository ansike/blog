---
title: 传输层
categories: 编程
tags:
  - 网络
date: 2023-05-04 17:35:01
---

来自[中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程](https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click&vd_source=22653c02dfbe0c9c7bb4a200eb87fe4e)


<a href="#overview">3.1 传输层概述</a>
<a href="#reuse">3.2 多路复用解复用</a>
<a href="#udp">3.3 无连接传输 UDP</a>
<a href="#rdt">3.4 可靠数据传输的原理</a>
<a href="#tcp">3.5 面向连接的传输 TCP</a>
<a href="#tcp">3.6 拥塞控制原理</a>
<a href="#tcp">3.7 TCP拥塞控制</a>

<h1 id="overview">3.0 传输层概述</h1>
- 理解传输层的工作原理
  - 多路复用/解复用
  - 可靠数据传输
  - 流量控制
  - 拥塞控制
- 学习internet的传输层协议
  - TCP
    - TCP的拥塞控制
  - UDP
  
<h1 id="reuse">3.1 多路复用解复用</h1>

TCP的复用和解复用

TCP的socket其实是以下四元组的一个数字标识和唯一一个PID对应
在连接建立之后在服务器和客户端都会在内存中建立一个唯一的socket连接
发送方发送数据时【源IP，源端口】=>【目标IP，目标端口】会复用该socket进行发送
接收方收到数据时解析数据包中的IP和端口信息，找到唯一的socket，把报文交给socket对应的process处理

**TCP socket map**
| socket | 源IP      | 源端口 | 目标IP    | 目标端口 | PID    |
| ------ | --------- | ------ | --------- | -------- | ------ |
| 12     | 127.0.0.1 | 80     | 127.0.0.2 | 8090     | 123123 |

> 浏览器在加载站点资源时通过创建多个socket连接来实现并发请求，此时每个socket请求的客户端端口都是不一样的。

TCP的复用和解复用
UDP的socket是二元组的一个数字标识和唯一的一个PID对应
UDP本身是面向无连接的，所以socket仅仅记录了自身IP，port和PID的对应关系
发送方通过同一个port发送数据时会使用同一个socket进行发送
接收方收到数据时解析数据包中的IP和port信息，找到唯一的socket，把报文交给socket对应的process处理
**UDP socket map**
| socket | 源IP      | 源端口 | PID    |
| ------ | --------- | ------ | ------ |
| 12     | 127.0.0.1 | 80     | 123123 |

<h1 id="reuse">3.2 无连接传输 UDP</h1>

UDP User Datagram Protocol [RFC 768]

UDP 只在IP层上增加了复用和解复用的能力

UDP使用的场景：流媒体，DNS，SNMP

在UDP上实现可靠传输：
- 在应用层增加可靠传输
- 应用特定的差错恢复

QQ的通讯就是基于UDP的OICQ应用层协议

**为什么没有第三种应用？**
TCP和UDP已经能支撑85%以上的应用

**为什么叫数据报**
每个数据都是独立发送的，IP也叫数据报

- udp头部比较小，payload比较大
- 没有拥塞控制，流量控制，发送比较快

UDP 校验和
- 目标：检测被传输报文段中的差错（如比特反转）
- 发送方
  - 将报文的内容视为16比特的整数
  - 校验和：报文段的加法和（1的补运算）
  - 发送方将校验和放在UDP的校验和字段
- 接收方
  - 计算机接收到的报文段的校验和
  - 检查计算出的校验和与校验和字段是否相等
    - 不想等：检测到有差错
    - 相等：没有检测到差错，但也有可能有差错
      - 残存错误


<h1 id="rdt">3.3 可靠数据传输的原理</h1>

**可靠数据传输（rdt [reliable data transfer]）的原理**
- rdt在应用层、传输层和数据链路层都很重要
- 是网络Top 10问题之一
{% asset_img 20230528-225749.jpeg rdt %}
- 信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性

渐进式的开发可靠数据传输协议
- rdt1.0 在可靠的信道上可靠数据传输
- rdt2.0 具有比特差错的信道
  - 下层信道可能出错：将分组中的比特反转
    - 用校验和来检测比特差错
  - 怎么从差错中恢复？
    - 确认（ACK）：接收方显示的告诉发送方分组已经被接受
    - 否定确认（NAK）：接收方显示的告诉发送方分组错误
      - 发送方收到NAK之后，发送方重传分组
  - rdt2.0中的新机制：采用差错控制编码进行差错检测 
    - 发送方差错控制编码、缓存 
    - 接收方使用编码检错 
    - 接收方的反馈：控制报文（ACK，NAK）：接收方->发送方 
    - 发送方收到反馈相应的动作
  - 致命的缺陷：ACK/NAK出错
    - 发送方不知道接收方发送了什么
    - 发送方如何做
      - 重传：可能重复
      - 不重传：可能死锁（或出错）
    - 引入新的机制：序号
- rdt2.1 在2.0上增加序号的能力
    - 发送方在每个分组中加入序号
    - 如果ACK/NAK出错，发送方重传当前分组
    - 接收方丢弃（不发给上层）重复分组
- rdt2.2 无NAK的协议
  - 功能同rdt2.1，但只使用ACK(ack 要编号）
  - 接收方对最后正确接收的分组发ACK，以替代NAK
    - 接收方必须显式地包含被正确接收分组的序号
  - 当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组
  - 为后面的一次发送多个数据单位做一个准备
    - 一次能够发送多个
    - 每一个的应答都有：ACK，NACK；麻烦
    - 使用对前一个数据单位的ACK，代替本数据单位的nak
    - 确认信息减少一半，协议处理简单
- rdt3.0：具有比特差错和分组丢失的信道
  - 下层信道可能会丢失分组（数据或ACK）
    - 会死锁
    - 机制还不够处理这种状况： 
      - 检验和 
      - 序列号
      - ACK
      - 重传
  - 方法：发送方等待ACK一段合理的时间
    - 发送端超时重传：如果到时没有收到ACK->重传
      - 问题：如果分组（或ACK ）只是被延迟了： 
        - 重传将会导致数据重复，但利用序列号已经可以处理这个问题 
        - 接收方必须指明被正确接收的序列号
      - 需要一个倒计数定时器
{% asset_img 20230528-225749.jpeg rdt %}
  
**停止等待协议**
发送方发送一个分组，然后等待接收方的应答。收到接收方的应答之后再发后续的分组

{% asset_img 20230530-090937.jpeg rdt3.0 %}
{% asset_img 20230530-090952.jpeg 流水线 %}
{% asset_img 20230530-091007.jpeg 流水线协议 %}

**滑动窗口(slide window)协议**
- 发送缓冲区 
  - 形式：内存中的一个区域，落入缓冲区的分组可以发送 
  - 功能：用于存放已发送，但是没有得到确认的分组 
  - 必要性：需要重发时可用
- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组 
  - 停止等待协议=1 
  - 流水线协议>1，合理的值，不能很大，链路利用率不能够超100%
- 发送缓冲区中的分组 
  - 未发送的：落入发送缓冲区的分组，可以连续发送出去；
  - 已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除

**GBN协议和SR协议的异同**
- 相同之处
  - 发送窗口>1
  - 一次能够可发送多个未经确认的分组
- 不同之处
  - GBN :接收窗口尺寸=1
    - 接收端：只能顺序接收 
    - 发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4 ; 假如1未成功，234都发送出去了，要返回1再发送；GB1
  - SR: 接收窗口尺寸>1
    - 接收端：可以乱序接收 
    - 发送端：发送0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发，选择性发送1

**流水线协议：总结**
- Go-back-N:
  - 发送端最多在流水线中有N个未确认的分组
  - 接收端只是发送累计型确认cumulative ack
    - 接收端如果发现gap，不确认新到来的分组
  - 发送端拥有对最老的未确认分组的定时器
    - 只需设置一个定时器
    - 当定时器到时时，重传所有未确认分组
- Selective Repeat: 
  - 发送端最多在流水线中有N个未确认的分组
  - 接收方对每个到来的分组单独确认individual ack（非累计确认）
  - 发送方为每个未确认的分组保持一个定时器
    - 当超时定时器到时，只是重发到时的未确认分组

<h1 id="tcp">3.5 面向连接的传输 TCP</h1>

**段结构**

TCP：概述 RFCs: 793, 1122, 1323, 2018, 2581
- 点对点：
  - 一个发送方，一个接收方
- 可靠的、按顺序的字节流：
  - 没有报文边界
- 管道化（流水线）：
  - TCP拥塞控制和流量控制设置窗口大小
- 发送和接收缓存
- 全双工数据：
  - 在同一连接中数据流双向流动
  - MSS：最大报文段大小 MTU internet的大小是 1500B
一个报文+20B的TCP头部+20B的IP头部，如果正好小于1500B则正好在一个报文段中，传输内容大小为1460B，超过1500B之后需要分段发送。
- 面向连接：
  - 在数据交换之前，通过握手（交换控制报文） 初始化发送方、接收方的状态变量
- 有流量控制：
  - 发送方不会淹没接收方

{% asset_img 20230531-090326.jpeg tcp 报文 %}

此图中的req和ack解释
- 改图描述了全双工的信息发送过程
- Seq 标识当前数据的序号，ACK则是对之前收到数据的确认（值为上次Seq+报文的长度），希望下次发送方发送数据从ACK的值开始
- ACK是累计确认，对下次接受数据的期待
{% asset_img 20230601-084345.jpeg tcp 序号和确认号 %}

TCP往返延时（RTT）和超时
<!-- TODO 计算方式没有看懂 -->
TimeoutInterval = EstimatedRTT + 4 * DevRTT（safety margin）
先计算一个往返时间的估计值+偏差范围的4倍，能覆盖绝大多数的超时 情况

**可靠数据传输**

- 快速重传
在超时定时器还没有到时间前，收到三个冗余的ACK，此时发送方会再次重传数据包。搞动作就是快速重传，因为此时还没有超时

- 三个冗余的ACK是怎么来的？
这个时候虽然没有超时，但是三个冗余ACK让发送方猜测序号较小的数据报出了问题，会立即重新发送，节约时间

- 初始的Seq为什么不从0开始？
<!-- TODO -->
初始的数据不是从0开始，而是双方会协商一个双向发送的Seq

TCP在数据传输过程中只启动一个定时器，当收到一个ACK时，移动base指针到ACK确认的位置。如果此时base指针小于next指针说明还有已发送未确认的包，则重新启动定时器，如果base和next相等则无已发送的包，关闭定时器。
{% asset_img 20230601-091627.jpeg TCP发送方事件 %}
