---
title: 从数字分隔符看正则表达式
categories: 编程
tags: js
date: 2021-05-05 22:46:13
---
### 格式化数字："1234567890"=>"1,234,567,890"
```javascript
// 第一种方案
"1234567890".replace(/\B(?=(\d{3})+(?!\d))/g,",") 
"1234567890".replace(/\B(?=(\d{3})+$)/g,",") 
// 第二种方案
"1234567890".replace(/(?<=\d)(?=(\d{3})+$)/g,',') 

```
<!-- 匹配的是后面是3*n个数字的非单词边界(\B) -->


### 第一种方案表达式分析
需求：给定数字字符串，从后往前每隔三位插入一个逗号分隔符
分析：该需求和普通的正则表达式处理需求不一样。一般常见的需求是使用正则表达式找到匹配的单词修改单词，如80%replace方法都是这种。 **而该需求是是使用正则表达式，找到合适的位置，在该位置插入字符串。**

**第一部分： \B 标识非单词边界**
匹配从非单词边界开始，反向理解一下就是从单词内部
```javascript
'a b'.replace(/\b/g,',') // ",a, ,b,"
'a b'.replace(/\B/g,',') // "a b"
```

**第二部分：(?=(\d{3})+(?!\d)) 查找位置**
```javascript
// (?=(\d{3})+(?!\d)) // 分解该部分
// ?= // 匹配后边的内容
// (\d{3})+ // 匹配数字3个一组，一次或者多次
// (?!\d) // 匹配后边的内容不是数字
// (\d{3})+(?!\d) // 所以这个整体的意思是数字三个一组至少一组，且三个一组的数字后边不是数字
```
第一种整体分析
1. 匹配从非单词边界开始，避免出现开头位置被抓取的case。
2. 然后从左往右开始扫描字符串，因为第一部分的原因，直接跳过1的左侧位置；
3. 到达2的左侧后发现正好可以匹配当前的位置此时可以在这个位置上插入分隔符【(\d{3})+(?!\d) 能和9个数字`234567890`匹配哦】；
4. 同理继续往后找，依次到达5的左侧和8的左侧和第三步一致，分别插入分隔符
**写完分析后发现其实可以直接用`$`将`(?!\d)`替换掉`"1234567890".replace(/\B(?=(\d{3})+$)/g,",")`**

### 第二种方案表达式分析
第二种整体分析-和第一种差不多，前置使用了左环的方案替代\B方案
1. 左环保证不会出现分隔符插在最左侧的情况
2. 使用右环查找为3倍数的数字位置，至少存在一组
3. 到达2的左侧，左边有数字，右边有三组3个数字，符合条件，插入分隔符
4. 同理继续往后找，依次到达5的左侧和8的左侧和第三步一致，分别插入分隔符

### 知识点总结

(?=pattern) 为右环视, 向右看是否有匹配的内容, 该动作不会消费原字符串
(?<=pattern) 为左环视, 向左看是否有匹配的内容, 该动作不会消费原字符串
(?:pattern)与(pattern)相对应, 第一个为非获取匹配, 第二个为获取匹配
[分析(?=pattern) (?!pattern) (?<=pattern) (?<!pattern)](https://blog.csdn.net/xichanjuan6481/article/details/89434402?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)
