---
title: 八股基础
categories: 编程
tags: js
date: 2022-04-17 16:24:45
---

1. <a href="#js">js 基础</a>
   1.1 <a href="#">js 闭包</a>
1. <a href="#frame">框架相关</a>
1. <a href="#engineering">工程化相关</a>
1. <a href="#h5">H5</a>
1. <a href="#server">服务相关</a>

<h2 id="js">js 基础</h2>

<h3 id="closure">闭包</h3>

概念：函数嵌套，内层函数引用外层函数变量。
例子：调用一个函数返回一个新的函数

### 原型链

概念：js 的对象中存在**proto**指向构造函数的 prototype，而构造函数 prototype 的**proto**会继续往上指，直到指向 Object.prototype.**proto** => null.
例子：const arr = new Array(); arr.**proto**===Array.prototype;

### 继承

js 中继承分主要有两部分组成：构造函数，原型链。其余各种继承都为这两种的排列组合。
构造函数继承即是执行构造函数，给 this 绑定属性。
原型链继承即是继承祖先类上的方法。
es6 中的 class 即使这两种继承的一个语法糖。

### 垃圾回收

js 的垃圾回收借鉴自 java，采用了自动垃圾回收机制。
因为 js 内存分为了新生代和老生代，自动垃圾回收的算法在不同的分代中采用的方式不一样。
新生代中主要使用了 scavenge 算法，
老生代使用了标记清楚+标记整理

### es6 语法

let const 块级作用域，定义可修改和常量变量（对比 var 都没有变量声明提前，都不可重复声明）
Set,Map
Proxy
Class
箭头函数
import/export

### js 中 commonjs，esm 区别

1. commonjs 输出为值的拷贝，esm 为值的引用
2. commonjs 同步加载，esm 异步加载
3. commonjs 运行时加载，esm 编译时输出接口

esm import 的模块不能重新赋值
esm 存在 export/import 提升

<h2 id="frame">框架相关</h2>

### react 和 vue diff 的异同

相同点：都是同级比较，跨级比较意义不是很大
不同点：

1. 对比节点时不同。相同节点，classname 不同，vue 会认为是不同的元素，会删除重建，react 则会修改节点属性
2. 对比顺序不同。vue 是从两端到中间，react 是从左到右。

### setState 是同步还是异步？

看到面试经常有人问 setState 是同步还是异步，其实这个问题直接问我我肯定会懵逼，我确实不知道，可见我见到的场景还是比较少。
就我使用 hooks 中所有场景来看，所有使用 setState 的地方其实预期都是异步的，而且就从 js 的生态来看，所有的耗时的更新操作都应该是异步的。就包括 react 的并发模式也是默认支持异步的，所以可以认为现在的同步模式只是 react 还没有完全处理完的问题，还是尽量少用，或者不需要去 care，默认就认为是异步即可。

##### 还是需要深入了解一下什么时候是异步，什么时候是同步？

在 React 事件处理函数中或 React 方法中是异步
在 setTimeout, Promise 等异步方法中或原生事件中是同步。
executionContext 为`BatchedContext`时为异步，`NoContext`为同步更新

### react，vue，angular 等前端框架 解决了什么问题？

在没有这些框架的时代，甚至连 jq 都么有的时候，我们实现一个业务逻辑只能自己去 get data，响应用户操作，执行预置逻辑，将用户操作结果提交给服务，最后给用户反馈。
我们有了趁手的工具 jq 之后，虽然整个逻辑流程没有变，但是编写业务逻辑的速度要比原生 js 要快很多。
再后来我们有个这几个框架之后就不一样了，不一样主要在两个地方：

- 响应用户操作；（绑定好视图和数据之后我们再也不用，手动将视图上的数据挪到发送给后端的 data 中）
- 界面给用户反馈；（服务响应之后，我们也不需要主动的去做 dom 变动）

其实仔细看下两个变动就是视图和数据的关系：**视图<=>数据**。从前端发展的这几十年之间，包括 js 的诞生无外乎就是为了处理视图和数据的关系。变化的方向必然是为了更为快速的开发，变化的历程其实就是命令式到声明式的转变。这种转变也是一种刀耕火种向现代化的转变，一切的逻辑都是可以预置的，一切结果都是可控的，这也是声明式的优点。

然后我们在看下这些框架是通过什么手段去尝试解决这个问题？

1. 代码书写方式由命令式变成声明式。声明式一定就好吗？当然没有绝对的东西，但是在巨型应用出现的今天，将所有的变动依托到框架中，声明式的代码确实是能节省很多的时间成本（主要是 debug）。
2. jsx 解决了 dom 的可编程问题。html 无法使用逻辑去编程，这一直以来都是前端比较大的痛点。
3. 制定自己的标准。按照一个优秀的标准去写代码至少会比我们天马行空的方式写出代码的代码要可读性强。

最后回到该问题，这些框架真的解决了这个问题吗？我的答案是没有。就像松哥之前说过这几个框架都是要被淘汰的，他们只是在当前的这个阶段，临时的缓解了前端开发工程师的阵痛。真正解决必然是浏览器才能解决的，但是到时候肯定又会出现其他的问题等着工程师们继续奋斗。

<h2 id="engineering">工程化相关</h2>

### webpack 解决了什么问题？

解决前端工程化中如何更高效的管理和维护项目的中的每个资源。
一个模块化解决方案

### npm 解决了什么问题？

js 的包管理器就是在解决前端工程的依赖包。【嗯，问这个问题的人脑子多少会有点问题。】

### yarn 解决了什么问题？

1. 依赖关系的确定性
2. 扁平式管理依赖
3. 离线模式（已安装的不再安装）

<h2 id="h5">H5</h2>

### 适配方案：rem，em，vw 简述

- rem: 根据不同屏幕设置 html 的 px，决定 1rem 的大小。本质是改变一个元素在不同设备上 css 像素的个数
- em: 继承父级设置的 font-size 大小
- vw: 100vw 是整个屏幕的宽度，相对整个屏幕的宽度计算当前元素的宽。

<h2 id="server">server</h2>

### 缓存击穿，缓存穿透，缓存雪崩怎么解决？
缓存击穿，穿透，雪崩差不多，都是redis中查询不到对应的数据或者缓存已过期，会将请求压力直接作用到底层的存储系统。涉及一些高并发的请求可能在瞬间就会将底层数据库打挂。
分析该问题，解决方案大致可以从请求前（1，2，3），请求处理中（4，5）和请求后（6）进行分别处理
1. 缓存预热。针对一些活动场景提前将热点数据写入缓存中并设置较大的超时时间；
2. 分散过期时间。避免将所有的key的过期时间设置的一致导致过期之后缓存雪崩；
3. 提前更新。记录缓存数据是否过期，快过期前提前进行数据刷新；
4. 空值缓存。查询的数据为空仍进行较短时间的缓存；
5. 使用锁，队列。避免瞬间将load数据的请求都打到数据库中；
6. 实时监控。对恶意ip进行封禁；
